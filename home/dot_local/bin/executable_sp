#!/usr/bin/env zsh
# ABOUTME: SSH host picker with fzf and tmux integration
# ABOUTME: Standalone script for use in tmux popups

# Debug mode: set SP_DEBUG=1 to see what's happening
if [[ -n "$SP_DEBUG" ]]; then
    exec 2>/tmp/sp-debug.log
    set -x
fi

SSH_CONFIG_DIR="${SSH_CONFIG_DIR:-$HOME/.ssh/config.d}"
HOSTS_FILE="/tmp/sp-hosts-$$"
DISPLAY_FILE="/tmp/sp-display-$$"

cleanup() {
    [[ -z "$SP_DEBUG" ]] && rm -f "$HOSTS_FILE" "$DISPLAY_FILE"
}
trap cleanup EXIT

# Verify config dir exists
if [[ ! -d "$SSH_CONFIG_DIR" ]]; then
    print "Error: SSH config directory not found: $SSH_CONFIG_DIR"
    read -k1 -s
    exit 1
fi

# Parse SSH configs into hosts file
for file in "$SSH_CONFIG_DIR"/*; do
    [[ -f "$file" ]] || continue
    [[ "$(basename "$file")" == "00-defaults" ]] && continue
    [[ "$(basename "$file")" == "05-github" ]] && continue

    current_host=""
    current_ip=""
    current_op=""

    while IFS= read -r line; do
        [[ -z "$line" ]] && continue
        [[ "$line" == \#* && "$line" != *"# OP:"* ]] && continue

        if [[ "$line" == Host\ * ]]; then
            if [[ -n "$current_host" && -n "$current_ip" ]]; then
                print -r -- "${current_host}|${current_ip}|${current_op}" >> "$HOSTS_FILE"
            fi
            current_host="${line#Host }"
            current_host="${current_host%% *}"
            [[ "$current_host" == *\** ]] && { current_host=""; continue; }
            current_ip=""
            current_op=""
        elif [[ "$line" == *HostName\ * ]]; then
            current_ip="${line#*HostName }"
            current_ip="${current_ip%% *}"
        elif [[ "$line" == *"# OP:"* ]]; then
            current_op="${line#*\# OP: }"
            current_op="${current_op%% *}"
        fi
    done < "$file"

    if [[ -n "$current_host" && -n "$current_ip" ]]; then
        print -r -- "${current_host}|${current_ip}|${current_op}" >> "$HOSTS_FILE"
    fi
done

# Check we have hosts
if [[ ! -s "$HOSTS_FILE" ]]; then
    print "No SSH hosts found in $SSH_CONFIG_DIR"
    print "Files checked:"
    ls -la "$SSH_CONFIG_DIR"
    read -k1 -s
    exit 1
fi

host_count=$(wc -l < "$HOSTS_FILE" | tr -d ' ')

# Create display list
while IFS='|' read -r host ip op; do
    print -r -- "$host ($ip)"
done < "$HOSTS_FILE" > "$DISPLAY_FILE"

# Verify display file has content
if [[ ! -s "$DISPLAY_FILE" ]]; then
    print "Error: Display file empty. Hosts file had $host_count entries."
    print "HOSTS_FILE content:"
    head -5 "$HOSTS_FILE"
    read -k1 -s
    exit 1
fi

# Clear fzf environment to prevent fallback to file finder
unset FZF_DEFAULT_COMMAND FZF_DEFAULT_OPTS

# Use fzf's --bind start:reload to load data without relying on stdin
# This works around tmux popup's tty stdin that breaks here-strings
FZF_RESULT_FILE="/tmp/sp-fzf-result-$$"
/opt/homebrew/bin/fzf \
    --multi \
    --reverse \
    --border=rounded \
    --border-label=" SSH Hosts ($host_count) " \
    --prompt='  ' \
    --pointer='▶' \
    --marker='✓' \
    --query="${1:-}" \
    --preview="h=\$(echo {} | cut -d' ' -f1); grep -h \"^Host \$h\$\" -A10 $SSH_CONFIG_DIR/* 2>/dev/null | head -12" \
    --preview-window='right:40%:wrap' \
    --header='Enter: window | C-p: pane | C-t: tiled | C-s: sync | Tab: multi' \
    --expect='ctrl-t,ctrl-s,ctrl-p' \
    --bind "start:reload(cat $DISPLAY_FILE)" \
    > "$FZF_RESULT_FILE" || { rm -f "$FZF_RESULT_FILE"; exit 0; }

fzf_result=$(<"$FZF_RESULT_FILE")
rm -f "$FZF_RESULT_FILE"

[[ -z "$fzf_result" ]] && exit 0

# Parse result
key_pressed=$(print -r -- "$fzf_result" | head -1)
selected_hosts=$(print -r -- "$fzf_result" | tail -n +2 | cut -d' ' -f1)

[[ -z "$selected_hosts" ]] && exit 0

# Determine layout
case "$key_pressed" in
    ctrl-t) layout="tiled" ;;
    ctrl-s) layout="sync" ;;
    ctrl-p) layout="pane" ;;
    *)      layout="window" ;;
esac

sel_count=$(print -r -- "$selected_hosts" | wc -l | tr -d ' ')

# Helper to get OP ref
get_op() {
    grep "^${1}|" "$HOSTS_FILE" | cut -d'|' -f3
}

# Helper to build command
build_cmd() {
    local h="$1" o="$2"
    # Use ct (chromaterm) wrapper if available for syntax highlighting
    local ssh_cmd="ssh"
    command -v ct &>/dev/null && ssh_cmd="ct ssh"

    if [[ -n "$o" ]]; then
        print -r -- "zsh -c 'sshpass -d 3 3< <(op read \"$o\") $ssh_cmd $h || read -k1 -s'"
    else
        print -r -- "$ssh_cmd $h || read -k1 -s"
    fi
}

# Build window name from hosts
first_host=$(print -r -- "$selected_hosts" | head -1)
if [[ "$sel_count" -gt 1 ]]; then
    win_name="${first_host}+${layout}"
else
    win_name="$first_host"
fi

# Execute based on layout
if [[ "$layout" == "pane" && "$sel_count" -eq 1 ]]; then
    # Single host: add to current window as pane
    cmd=$(build_cmd "$first_host" "$(get_op "$first_host")")
    tmux split-window "$cmd"
    tmux select-layout tiled
elif [[ "$layout" == "pane" && "$sel_count" -gt 1 ]]; then
    # Multiple hosts with C-p: new window with just those hosts
    first=true
    print -r -- "$selected_hosts" | while IFS= read -r h; do
        cmd=$(build_cmd "$h" "$(get_op "$h")")
        if $first; then
            tmux new-window -n "$win_name" "$cmd"
            first=false
        else
            tmux split-window "$cmd"
            tmux select-layout tiled
        fi
    done
elif [[ "$layout" == "window" && "$sel_count" -eq 1 ]]; then
    # Single host in new window
    cmd=$(build_cmd "$first_host" "$(get_op "$first_host")")
    tmux new-window -n "$win_name" "$cmd"
else
    # Multiple hosts in new window (tiled or sync)
    first=true
    print -r -- "$selected_hosts" | while IFS= read -r h; do
        cmd=$(build_cmd "$h" "$(get_op "$h")")
        if $first; then
            tmux new-window -n "$win_name" "$cmd"
            first=false
        else
            tmux split-window "$cmd"
            tmux select-layout tiled
        fi
    done
    [[ "$layout" == "sync" ]] && tmux set-window-option synchronize-panes on
fi
